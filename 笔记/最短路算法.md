## 最短路算法

#### 单源最短路 

+ 所有边权都是正数
  + 朴素Dijkstra算法 
  
    + O(V^2^)  O(n^2^)
  
    + 稠密图 $E\approx V^2$ 用邻接矩阵存图
  
      ```markdown
      集合S={当前已经确定最短距离的点}
      dist[1]=0,dist[其他点]=+∞
      for i:1~n (循环n次)
      	t<-不在S中(没有确定最短距离)的离1号最近的点
          s<-t，t就是已经确定最短距离的点了
          用t更新其他点的距离
      ```
  
  + 堆优化版的Dijkstra算法 
  
    + O(ElogV)  O(mlogn)
    + 稀疏图 $E\approx V$ 用邻接表存图
    + 堆实现方式：
      + 手写堆
      + STL优先队列（可能有冗余）
+ 存在负边权
  + Bellman-Ford 
  
    + O(VE) O(mn)
  
    + 如果存在负权环路，最短路可能不存在
  
      ```
      for n 次 (迭代k次涵义：从1号点经过不超过k条边的最短距离)
      	for 所有边 a->b w
      		dist[b]=min(dist[b],dist[a]+w) 松弛操作
      存边:
      	struct Edge{
      		int a,b,w;
      	}edge[M];
      ```
  
  + SPFA 
  
    + 一般O(E) O(m)  这时候可以代替堆优化Dijkstra
  
    + 最坏O(VE) O(mn)
  
    + 图中不可以含有负权环路
  
      ```
      优化思路，当dist[a]变小时才需要更新dist[b]
      借助队列来实现,队列存储更新过变小的点。(队列元素不要重复存储，入队出队时更新维护状态变量)
      
      dist[x]表示1->x的最短距离
      cnt[x]表示最短路径上的边数
      cnt[x]>=n,表示至少经过了n条边，则至少经过了n+1个点，故肯定有负权环路
      ```

#### 多源最短路

+ Floyd算法 

  + O(V^3^) O(n^3^)

  + 邻接矩阵存图

  + 可以处理负权图，但不能有负权环路

    ```
    d[k,i,j]表示i->1~k->j,从点i只经过1~k这些中间点到达j的最短距离
    d[k,i,j]=d[k-1,i,k]+d[k-1,k,j]
    d[i,j]=d[i,k]+d[k,j]
    for(k=1;k<=n;++k){
    	for(int i=1;i<=n;++i){
    		for(int j=1;j<=n;++j){
    			d[i,j]=min(d[i,j],d[i,k]+d[k,j]);
    		}
    	}
    }
    d[i,j]表示i->j的最短路长度
    ```

    



